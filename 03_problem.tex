\chapter{Постановка задачи \label{sct:problem-constraints}}

Данный раздел посвящен анализу требований, которым должен удовлетворять разрабатываемый механизм классов типов. На данном этапе уже понятно, каким образом должны функционировать классы типов. Таким образом, в первую очередь следует сосредоточиться на выборе способа введения семантики классов типов в язык программирования Kotlin. Особое внимание здесь стоит уделить прозрачности вводимых синтаксических конструкций с точки зрения пользователя, а также по возможности избежать конфликтов с уже существующей семантической моделью языка. В конце рассмотрим инструментальные средства, позволяющие реализовать выбранный подход на практике.

В рамках данной работы необходимо разработать и реализовать механизм классов типов в языке программирования Kotlin~\cite{kotlin}. Разрабатываемое решение должно удовлетворять следующим базовым требованиям:
\begin{enumerate}
    \item Для всякой пары класса типов и типа, входящего в него, допускается существование не более одного экземпляра этого класса типов.
    \item Объявление класса типов должно выражаться в явной форме.
    \item Ограничение на принадлежность типовой переменной классу типов должно выражаться в явной форме.
\end{enumerate} 
В предыдущем разделе было показано, что допущение о наличии нескольких экземпляров класса типов для одного и того же значения его типовой переменной может существенно затруднить понимание исходного кода программы. Первое требование, конечно, само по себе не позволяет гарантировать объективное улучшение качества кода, однако, по крайней мере, упрощает задачу поиска подходящего экземпляра класса типов с точки зрения пользователя. Второе и третье требования также позволяют сделать разрабатываемый подход более прозрачным для понимания. 

\section{Введение семантики классов типов \label{sct:problem-semantic}}

Для введения семантики классов типов в язык программирования Kotlin было решено использовать подход, аналогичный тому, который используется в языке программирования Scala. Данный подход позволяет интуитивно понятным образом совместить объявления класса типов и его экземпляров с синтаксической моделью язка Kotlin. Заметим, однако, что согласно сформулированным требованиям и в противовес подходу, представленному в языке Scala, необходимо, чтобы класс типов объявлялся явным образом. Наиболее прозрачным способом достичь этого представляется введение нового ключевого слова, которое будет использоваться при объявлении интерфейса, описывающего класс типов. Такой подход, однако, является достаточно сложным с точки зрения реализации, поскольку на этапе разбора грамматики языка Kotlin перед компиляцией не используется никаких сторонних утилит, которые в явном виде описывали бы грамматику языка. По этой причине в рамках данной работы было решено отказаться от модификации синтаксиса языка Kotlin, а для введения дополнительных семантических элементов использовать механизм аннотаций. Так, например, можно определить специальную аннотацию \code{@TypeClass}, которая будет использоваться для маркировки тех интерфейсов, определения которых представляют также и описание классов типов. Рассмотрим теперь ограничения на принадлежность типовой переменной классу типов. В языке программирования Scala такие ограничения в общем случае выражаются неявным образом через определение неявного аргумента функции. В силу отказа от модификации синтаксиса языка Kotlin, в рамках данной работы не представляется возможным расширение определений функций списком дополнительных неявных параметров. Для решения этой проблемы были рассмотрены следующие способы введения подобных ограничений:
\begin{itemize}
    \item Неявные аргументы, играющие роль словарей функций классов типов, объявляются вместе с обычными аргументами функций. В этом случае, конечно, всякий неявный аргумент должен быть помечен специальным образом для того, чтобы его можно было отличить от обычных аргументов. 
    \item Ограничение на принадлежность типовой переменной \code{T} классу типов \code{C} может быть выражено следующим образом: существует тип \code{I} такой, что \code{I} является наследником типа \code{C} с параметром \code{T}. Такая запись может быть размещена прямо в месте объявления типовых переменных функции и также помечена явным образом.
\end{itemize}
В обоих подходах для выделения соответствующих синтаксических конструкций также могут быть использованы аннотации. Таким образом, оба решения удовлетворяют третьему базовому требованию.  

Пример введения семантики классов типов с использованием аннотаций представлен в листинге~\ref{lst:annotation-semantic-example}. Опишем семантику аннотаций, использованных в данном примере:
\begin{itemize}
    \item Класс или интерфейс, помеченный аннотацией \code{@TypeClass}, описывает набор операций, представленных в одноименном классе типов.
    \item Типовая переменная, помеченная аннотацией \code{@TypeClass}, описывает ограничение на принадлежность типовой переменной некоторому классу типов.
    \item Аргумент функции, помеченный аннотацией \code{@TypeClassDictionary}, играет роль словаря функций соответствующего класса типов. Такие аргументы запрещено указывать явно в точке вызова. 
\end{itemize}
Зафиксируем описанную таким образом семантику для дальнейшего использования в данной работе. 

\lstinputlisting[
    label={lst:annotation-semantic-example},
    caption={Пример введения семантики классов типов с использованием аннотаций},
    style={kotlin}
]
{resources/05/04_concept_example}

Стоит также отметить, что, поскольку классы типов синтаксически выражаются через обычные интерфейсы и классы, для выполнения требования о единственности экземпляра класса типов, необходимо запретить наследование между теми интерфейсами и классами, которые описывают классы типов. 

\section{Выбор инструментальных средств реализации}

Перейдем к рассмотрению технических инструментов, позволяющих расширить функциональность программы без или с минимальным вовлечением разработчика. Наибольшие технические сложности при решении поставленной задачи вызывает подстановка неявных аргументов в точку вызова определенных функций, поэтому все представленные подходы будем рассматривать с точки зрения применимости к данной проблеме.

Сразу же отметим, что в рамках данной работы не рассматривались варианты, суть которых состоит в генерации дополнительного исходного кода перед компиляцией программы. Во-первых, автоматически генерируемый код, как правило, достаточно сложно поддерживать и фактически запрещено модифицировать. С таким положением дел можно мириться в случае, когда автоматически генерируемый код локализован, однако в случае с классами типов может понадобится модификация всех вызовов произвольной функции (добавить неявный аргумент), которые невозможно или крайне сложно локализовать в одной небольшой части программы без потери гибкости и, не нарушая основных принципов проектирования программного обеспечения. Во-вторых, автоматически генерируемый код не обладает никакими привилегиями по сравнению с пользовательским кодом. Иными словами, любой сгенерированный код может быть написан пользователем самостоятельно. Основной проблемой здесь является механизм \emph{стирания типов} (\emph{type erasure}), который присутствует в языках программирования семейства Java. В результате работы данного механизма во время исполнения программы пользователю не доступна почти вся информация об \emph{обобщенных типах} (\emph{generic types}). 

Рассмотрим данную проблему более подробно. Для того, чтобы использовать функцию, описанную пусть даже в заранее известном классе типов \code{C}, необходимо сначала найти подходящий его экземпляр. В случае, когда точно известно для какого члена класса типов \code{C} необходимо найти реализацию, задача выглядит достаточно тривиальной: для ее решения можно использовать, например, программный интерфейс рефлексии (reflection api). Пусть член класса типов неизвестен и выражается типовой переменной \code{T}. Тогда задача определения конкретного типа, который в действительности был использован на месте \code{T}, строго говоря, не может быть решена в языках программирования семейства Java. Если функция имеет хотя бы один аргумент типа \code{T}, то можно получить информацию о типе данного аргумента и затем использовать ее для поиска подходящего экземпляра. Здесь, однако, следует понимать, что действительный тип аргумента может отличаться от значения \code{T}, вычисленного на этапе компиляции. Даже если допустить, что экземпляр класса типов для действительного типа аргумента является корректным решением, тут же возникают проблемы в случаях, когда в функции отсутствуют аргументы типа \code{T} или их более одного.

Таким образом, из-за наличия механизма стирания типов в языках программирования семейства Java также не представляется возможным реализовать необходимую функциональность в виде набора библиотечных классов и функций. Строго говоря, данный механизм препятствует использованию любых инструментов, которые не работают непосредственно на этапе компиляции программы. По этой причине также неприменимы такие инструментальные средства, как обработка аннотаций (annotation processing) и обработка байт-кода программы (bytecode manipulation). Таким образом, единственным способом, допускающим реализацию концепции классов типов в языке программирования Kotlin, представляется модификация компилятора данного языка программирования. 