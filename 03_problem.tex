%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Постановка задачи}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе сначала приведем развернутое определение класса типов, а затем опишем цель работы и ограничения, накладываемые на конечный результат.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Класс типов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}[Класс типов\label{def:type-class}]
Класс типов является сущностью, обеспечивающей функционирование специального полиморфизма. Это достигается путем наложения ограничения на переменную типа в параметрическом полиморфизме следующего характера: пусть $C$ --- класс типов, $T$ --- типовая переменная, тогда множество допустимых значений $T$ в точности соответствует множеству типов, над которыми определены все операции, ассоциированные с $C$.  
\end{definition}

На первый взгляд, ограничение, описанное в определении \ref{def:type-class} выглядит достаточно слабым, тем более что лимитирующие условия подобного рода уже реализованы в объектно-ориентированных языках программирования посредством \emph{полиморфизма подтипов} (\emph{subtyping polymorphism}). Однако полиморфизм подтипов имеет ограниченную область применимости в том смысле, что требует включения конкретного типа (в терминах специального полиморфизма) в некоторую иерархию, и, следовательно, не может обеспечивать полноценное функционирование специального полиморфизма (поскольку не все типы могут быть модифицированы). Таким образом, естественной представляется возможность реализации функций классов типов для конкретных типов отдельно от определения этих типов. В сравнении с полиморфизмом подтипов такой подход уже выглядит более мощным, поскольку допускает расширение функциональных возможностей существующих иерархий типов без модификации как самой иерархии, так и типов, входящих в нее. Иными словами, в некоторых случаях гарантируется выполнение \emph{принципа открытости/закрытости} (\emph{open/closed principle}), что является существенным плюсом с точки зрения программной архитектуры. Помимо этого, заметим, что в параметрически полиморфных функциях аргументы, типы которых ограничены принадлежностью к некоторому классу типов, не являются носителями функций, определенных в классе типов (в отличии от полиморфизма подтипов). Это значит, что функции классов типов, в данном случае не включены в таблицу виртуальных методов аргументов и, следовательно, могут иметь единую реализацию для всех аргументов одного и того же типа, что позволяет существенно повысить выразительность типового языка программирования.

Также заметим, что определение класса типов распространяется и на случай нескольких типовых переменных. В этом случае целесообразно говорить не об одном конкретном типе, но о кортеже. В дальнейшем, не умаляя общности, будем говорить о классах типов с единственной типовой переменной, если не указано обратного.

% \begin{figure}[htbp]
% \centering
% \includegraphics[width=\textwidth]{how-to-do-the-actual-research}
% \caption{Рекомендации по проведению исследований в рамках диссертации}%
% \label{fig:how-to-do-research}
% \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Цель работы \label{sct:problem-constraints}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В рамках данной работы необходимо разработать и реализовать механизм классов типов в языке программирования Kotlin. При этом необходимо, чтобы полученное решение не шло вразрез с философией Kotlin. Такое требование достаточно сложно формализовать, однако де факто в нем выражается стремление к достижению следующих свойств:
\begin{enumerate}
    \item \label{it:rp-01} Объективная простота по сравнению с подходом, предлагаемым в языке программирования Scala.
    \item \label{it:rp-02} Максимальная прозрачность с точки зрения пользователя.
\end{enumerate} 
В процессе обработки данных свойств были выработаны следующие базовые требования к решению: 
\begin{enumerate}
    \item Для всякого класса типов и всякого конкретного типа допускается существование не более одной реализации.
    \item Объявление класса классом типов должно выражаться в явной форме.
    \item Ограничение на принадлежность типовой переменной классу типов должно выражаться в явной форме.
    \item Разрешение типов для классов типов должно быть реализовано статическим образом. 
\end{enumerate}

% Поскольку Kotlin является объектно-ориентированным языком программирования, целесообразными представляются следующие утверждения:
% \begin{itemize}
%     \item Объявление класса типов аналогично объявлению параметризуемого интерфейса или (возможно абстрактного) класса. Таким образом, в Kotlin класс типов также будет являться абстрактным типом. 
%     \item Реализация функций, присущих классу типов $C$, для конкретного типа $A$ естественным образом выражается в виде реализации соответствующего типа с параметром $A$.
%     \item Ограничение на принадлежность типовой переменной $T$ классу типов $C$ может быть выражено следующим образом: существует тип $I$ такой, что $I$ является наследником типа $C$ с параметром $T$.
% \end{itemize}  

% Теперь необходимо понять можно ли реализовать нечто подобное в языке программирования Kotlin. Прежде всего вспомним, что Kotlin является языком для java-машины (jvm), при этом сам язык программирования java не поддерживает механизм классовых типов. Возникает вопрос: выполнима ли поставленная задача в принципе? Иными словами: нет ли каких-либо ограничений со стороны java-машины, препятствующих реализации требуемого механизма. Ответ на этот вопрос --- нет, поскольку уже существует язык программирования для виртуальной java-машины, который предоставляет пользователям механизм классовых типов, --- Scala. 