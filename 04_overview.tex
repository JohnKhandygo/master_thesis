\chapter{Обзор существующих решений}

Данный раздел посвящен обзору механизмов классов типов, представленных в других языках программирования. В рамках данного обзора большое внимание уделялось функциональным возможностям, которые доступны пользователю при работе с классами типов в рассматриваемых языках программирования. Кроме того, следует отметить особенности введения семантики классов типов в объектно-ориентированных языках программирования. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Классы типов в Haskell \label{sct:overview-haskell}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В языке программирования Haskell механизм классов типов реализуется посредством следующих языковых конструкций: \emph{объявление класса типов} (\emph{type class declaration}), \emph{объявление экземпляра класса типов} (\emph{type class instance declaration}) и \emph{специализированных типов} (\emph{qualified types}). Рассмотрим все три составляющие на примере простейшей задачи реализации оператора сравнения над некоторым конечным множеством типов. В Haskell отсутствуют классы в том виде, как они представлены в объектно-ориентированном программировании, также отсутствует и полиморфизм подтипов. Стандартным способом решения таких задач в Haskell является использование классов типов.

Объявление класса типов определяет набор именованных операций, для каждой из которых обязательно указываются типы всех аргументов и тип возвращаемого значения. Таким образом, объявление класса типов в Haskell схоже с объявлением интерфейса в объектно-ориентированных языках программирования. Пример объявления класса типов, который будет использоваться для решения поставленной задачи приведен в листинге \ref{lst:haskell-example-define-typeclass}.    

\lstinputlisting[
    firstline=1,
    lastline=3,        
    label={lst:haskell-example-define-typeclass},
    caption={Пример определения класса типов в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Здесь \code{CanEq} --- имя определяемого класса типов, \code{a} --- типовая переменная. Данное определение следует трактовать следующим образом: <<всякий тип \code{a}, принадлежащий к классу типов \code{CanEq}, имеет две операции \code{eq} и \code{neq}, каждая из которых возвращает значение типа \code{Bool}, когда применяется к двум аргументам типа \code{a}>>. Для удобства определим реализацию по умолчанию для одной из функций, описанных в \code{CanEq}. Для этого расширим определение класса типов как показано в листинге \ref{lst:haskell-example-default-impl}.

\lstinputlisting[
    firstline=4,
    lastline=4,        
    label={lst:haskell-example-default-impl},
    caption={Пример предоставления реализации по умолчанию для классов типов в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Пусть необходимо объявить о принадлежности типа \code{Bool} к классу типов \code{CanEq}. Для этого определим экземпляр класса типов \code{CanEq} как показано в листинге \ref{lst:haskell-example-define-instance}.

\lstinputlisting[
    firstline=6,
    lastline=9,        
    label={lst:haskell-example-define-instance},
    caption={Пример объявления экземпляра класса типов в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Объявление экземпляра класса типов начинается с ключевого слова \code{instance}, затем указывается имя класса типов, а вместо типовой переменной \code{a} теперь используется тип, для которого определяется экземпляр. В теле объявления экземпляра класса типов реализуются все функции, объявленные в соответствующем классе типов, за исключением, быть может, тех функций, для которых в классе типов представлены реализации по умолчанию. Здесь также важно отметить, что в Haskell допускается существование не более одного экземпляра для всякой пары класса типов и конкретного типа. 

Специализированные типы, в свою очередь, позволяют наложить ограничение на принадлежность типовой переменной некоторому классу типов. Так, например, можно объявить функцию \code{memberOf} как показано в листинге \ref{lst:haskell-example-test}. 

\lstinputlisting[
    firstline=11,
    lastline=11,        
    label={lst:haskell-example-test},
    caption={Пример функции, использующей специализированные типы в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Такое определение следует трактовать следующим образом: <<для всякого типа \code{t}, принадлежащего классу типов \code{CanEq}, функция \code{memberOf} принимает два аргумента типа \code{t} и списка над типом \code{t} и возвращает значение типа \code{Bool}>>. Префикс \code{CanEq t =>} в типе функции \code{memberOf} --- это и есть та часть синтаксиса Haskell, которая делает тип специализированным.

На этапе компиляции информация, предоставляемая объявлениями классов типов и их экземпляров, а также специализированными типами, преобразуется следующим образом:
\begin{itemize}
    \item Для всякого объявления класса типов генерируется описание словаря функций этого класса типов. Словарь функций представляется в виде структуры данных, содержащей указатели на функции, описание которых (имя, сигнатура) в точности соответствует описанным в классе типов. 
    \item Для всякого объявления экземпляра класса типов генерируется экземпляр словаря соответствующего класса типов. 
    \item Для каждой функции специализированного типа в список ее аргументов добавляется дополнительный параметр, тип которого соответствует типу словаря функций используемого класса типов. Этот дополнительный аргумент затем используется как носитель реализаций функций, описанных в соответствующем классе типов. 
\end{itemize}
Для каждого вызова функции специализированного типа компилятор ищет подходящий экземпляр использующегося класса типов, и, в случае успеха, передает словарь его функций вместе со списком остальных аргументов в точку вызова. Ниже, в листинге \ref{lst:haskell-example-pseudo-impl} представлен код, демонстрирующий описанные выше преобразования на примере рассмотренной ранее задачи. 

\lstinputlisting[
    label={lst:haskell-example-pseudo-impl},
    caption={Пример псевдокода, который генерирует компилятор Haskell при работе с классами типов},
    style={haskell}
]
{resources/04/02_haskell_example_pseudo_impl}

Здесь стоит отметить, что, хотя исходный код, представленный в листинге \ref{lst:haskell-example-pseudo-impl}, может быть использован для решения поставленной ранее задачи без вовлечения классов типов, такой подход достаточно сложно применить на практике, поскольку в точке вызова функции \code{memberOf} пользователь берет на себя ответственность за то, чтобы передать в функцию подходящий экземпляр словаря класса типов, в то время как в случае использования классов типов за это отвечает компилятор. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Классы типов в Scala}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В языке программирования Scala классы типов представлены в виде шаблона проектирования, который построен на базе механизма \emph{неявных деклараций} (\emph{implicits}). Данное расширение языка Scala позволяет при помощи ключевого слова \code{implicit} описать неявное преобразование типов (implicit conversions) и его специальный случай --- неявные классы (implicit classes), а также определить неявные аргументы функций (implicit parameters). Рассмотрим каждый из этих механизмов отдельно.

Неявное преобразование типа \code{T1} в тип \code{T2} может быть представлено неявной переменной, тип которой соответствует функции \code{T1 => T2}, или неявным методом того же типа. Неявные преобразования применяются в двух случаях:
\begin{enumerate}
	\item Когда некоторое выражение \code{e} имеет тип \code{T1}, который не соответствует ожидаемому типу \code{T2}.
	\item Когда в выражении вида \code{e.f} \code{e} имеет тип \code{T1} и \code{f} не является членом этого типа. 
\end{enumerate}
В обеих ситуациях компилятор предпримет попытку поиска преобразования, которое может быть применено к \code{e}. При этом в первом случае результат искомого преобразования должен удовлетворять типу \code{T2}. Во втором случае дополнительным ограничением является требование наличия у результата искомого преобразования члена \code{f}, доступного в контексте выражения \code{e}. Так, например, в примере, представленном в листинге \ref{lst:scala-implicit-conversion-example}, согласно второму правилу экземпляр класса \code{CanFoo} \code{f} перед вызовом функции \code{bar} будет преобразован к типу \code{CanBar} посредством применения неявного преобразования, описанного в функции \code{foo2bar}. Соответственно, в результате исполнения кода, представленного в листинге  \ref{lst:scala-implicit-conversion-example}, будут выведены последовательно два сообщения: \code{inside bar} и \code{foo}.

\lstinputlisting[
    label={lst:scala-implicit-conversion-example},
    caption={Пример использования неявных преобразований в Scala},
    style={scala}
]
{resources/04/04_scala_implicit_conversion_example}

Неявные классы также позволяют описать неявное преобразование одного типа в другой. Здесь в качестве функции, выполняющей непосредственную конвертацию типов, выступает конструктор неявного класса. Таким образом, неявные классы являются специальным случаем неявного преобразования, тип результата которого строго ограничен типом самого неявного класса. Объявление неявного класса аналогично объявлению обычного класса, но обязательно предваряется ключевым словом \code{implicit}. Пример использования неявных классов представлен в листинге \ref{lst:scala-implicit-class-example}. Здесь неявный класс \code{DoubleCanFoo} определяет неявное преобразование типа \code{Double} в тип \code{DoubleCanFoo}, что позволяет вызывать функцию \code{foo} на экземплярах типа \code{Double}. В результате исполнения кода, представленного в листинге \ref{lst:scala-implicit-class-example}, будет выведено единственное сообщение \code{foo with 3.14}.

\lstinputlisting[
    label={lst:scala-implicit-class-example},
    caption={Пример использования неявных классов в Scala},
    style={scala}
]
{resources/04/05_scala_implicit_class_example}

На определение неявных классов накладываются следующие ограничения:
\begin{itemize}
	\item Неявный класс может быть объявлен только внутри другого класса.
	\item Первичный конструктор (primary constructor) неявного класса должен иметь в точности один явный параметр.
	\item В области объявления неявного класса не должно быть других членов или объектов с таким же именем.
\end{itemize}
Все эти ограничения объясняются тем, что в процессе компиляции всякий неявный класс будет преобразован в идентичный с точностью до ключевого слова \code{implicit} класс и неявную функцию, сигнатура которой полностью (включая имя) повторяет сигнатуру первичного конструктора этого неявного класса. Тело такой функции состоит из вызова конструктора сгенерированного класса. Так, например, определение неявного класса \code{DoubleCanFoo}, представленное в листинге \ref{lst:scala-implicit-class-example}, в процессе компиляции будет преобразовано так, как показано в листинге \ref{lst:scala-implicit-class-transformation}.

\lstinputlisting[
    label={lst:scala-implicit-class-transformation},
    caption={Пример преобразования неявных классов в процессе компиляции},
    style={scala}
]
{resources/04/06_scala_implicit_class_transformation}

В языке программирования Scala определение всякой функции может быть расширено дополнительным списком неявных аргументов. Список неявных аргументов объявляется также, как и обычный, но с указанием ключевого слова \code{implicit} перед ним. Неявные аргументы могут быть переданы в точку вызова так же, как и обычные аргументы. В то же время в точке вызова функции, использующей неявные параметры, допускается пропуск всех аргументов, помеченных как \code{implicit}. В этом случае значения всех неявных аргументов будут вычислены и подставлены компилятором самостоятельно, без участия пользователя. Пример использования неявных параметров представлен в листинге \ref{lst:scala-implicit-parameters-example}. 

\lstinputlisting[
    label={lst:scala-implicit-parameters-example},
    caption={Пример использования неявных параметров в Scala},
    style={scala}
]
{resources/04/07_scala_implicit_parameters_example}

Процесс поиска подходящих значений неявных аргументов заключается в последовательном сканировании областей видимости, доступных в рассматриваемой точке вызова, и поиске в этих областях неявных объявлений, подходящих для использования вместо неявных аргументов. При разрешении конфликтов между кандидатами учитывается приоритет, закрепленный за каждой из просматриваемых областей видимости. В случае если этого критерия недостаточно для разрешения неоднозначности, компилятор предпримет попытку выбрать наиболее точный из них в соответствии с правилами статического разрешения перегрузок. Стоит также отметить, что в некоторых случаях объявление неявных аргументов может быть заменено так называемыми \emph{контекстными ограничениями} (\emph{context bounds}). Контекстные ограничения подразумевают наличие типовой переменной \code{T} и параметризованного типа \code{C} и позволяют объявить о наличии неявного параметра типа \code{T[C]}. Так, например, определение функции \code{doFoo}, представленное в листинге \ref{lst:scala-implicit-parameters-example}, может быть переписано с использованием контекстных ограничений, как показано в листинге \ref{lst:scala-context-bounds-usage}. При этом в вызове функции \code{doFoo} также допускается указание значений неявных аргументов в явном виде. 

\lstinputlisting[
    label={lst:scala-context-bounds-usage},
    caption={Пример использования контекстных ограничений в Scala},
    style={scala}
]
{resources/04/08_scala_context_bounds_usage}

Таким образом, контекстные ограничения могут служить заменой определений неявных аргументов специального вида, которые не используются в теле функции в явном виде. Более того, в процессе компиляции, все контекстные ограничения заменяются соответствующими им неявными аргументами.  

Заметим также, что существует особый случай, в котором неявное объявление является одновременно и неявным преобразованием, и неявным аргументом. Пример такой ситуации представлен в листинге \ref{lst:scala-both-implicits-example}. 

\begin{lstlisting}[
    label={lst:scala-both-implicits-example},
    caption={Пример использования неявного аргумента в качестве неявного преобразования тпиов в Scala},
    style=scala
]
def findValue[T, CC](seq: CC, value: T)(implicit conv: CC => Seq[T]) = 
    seq.indexOf(value)
\end{lstlisting}

В языке программирования Scala отсутствуют специальные синтаксические выражения, предназначенные для описания классов типов. Вместо этого семантика классов типов переносится на уже существующие языковые конструкции, а вся необходимая функциональность обеспечивается механизмом неявных объявлений. Именно поэтому в Scala принято говорить о классах типов как о шаблоне проектирования. Как и в Haskell, использование классов типов в Scala подразумевает наличие трех семантических конструкций, описывающих объявления класса типов, его экземпляров и ограничение на принадлежность типовой переменной классу типов. Scala, однако, является объектно-ориентированным языком программирования, и потому каждый из этих этапов реализован несколько иначе, чем в языке программирования Haskell. Особенности определения семантики классов типов в Scala выражается в следующих аспектах:
\begin{itemize}
    \item Объявлению класса типов соответствует описание параметризованного интерфейса. 
    \item Факт принадлежности типа \code{X} классу типов выражается через реализацию интерфейса, соответствующего классу типов, для значения типового параметра, равного \code{X}. Другими словами, объявлению экземпляра класса типов соответствует описание наследника интерфейса, представляющего класс типов.  
    \item Принадлежность типовой переменной \code{T} классу типов \code{C} выражается через определение неявного аргумента, тип которого равен \code{C[T]}, или при помощи контекстного ограничения \code{T : C}.    
\end{itemize}
Здесь прослеживается прямая аналогия с синтаксическими конструкциями, предназначенными для описания классов типов в языке программирования Haskell. При этом, поскольку экземпляр интерфейса в объектно-ориентированных языках программирования уже является носителем всех функций, присущих этому интерфейсу, нет необходимости генерировать какие-либо дополнительные структуры данных, описывающие словарь функций класса типов. Таким образом, неявные переменные играют роль словарей функций соответствующего класса типов, а использование контекстных ограничений в некоторых случаях позволяет упростить эту запись. Пример использования классов типов для решения поставленной ранее задачи введения операции сравнения над некоторым конечным множеством типов представлен в листинге \ref{lst:scala-example}.

\lstinputlisting[
    label={lst:scala-example},
    caption={Пример использования классов типов в Scala},
    style={scala}
]
{resources/04/03_scala_example}

Несмотря на синтаксическую и семантическую схожесть реализаций механизма классов типов в языках программирования Scala и Haskell, между ними присутствует существенное различие, которое заключается в том, каким образом разрешаются вызовы функций, использующие классы типов. Ключевым моментом здесь является процесс вычисления подходящего экземпляра класса типов в точках вызова таких функций. В то время как в Haskell допускается существование единственного экземпляра класса типов для всякой пары класса типов и типа, в Scala поиск подходящего экземпляра класса типов осуществляется в соответствии с правилами разрешения неявных деклараций, что приводит к возможности наличия более чем одного экземпляра класса типов, доступного в точке вызова. С одной стороны, такой подход предоставляет возможность очень гибкого управления зависимостями внутри программы, с другой стороны, исходный код, в котором используются классы типов, может быть крайне сложен для понимания, отладки и разработки. Данное утверждение может быть обосновано следующим образом: в общем случае невозможно достоверно утверждать, требуются ли в точке вызова некоторой функции для корректной ее работы какие-либо неявные определения. Даже если про некоторый вызов внутри программы точно известно, какие неявные параметры необходимо в него передать, задача вычисления мест расположения неявных деклараций, которые в действительности будут выбраны компилятором для передачи в этот конкретный вызов, может быть весьма трудоемкой, учитывая, что  для инициализации подходящих неявных определений могут потребоваться другие неявные определения. Кроме того, из всех подходящих определений затем следует выбрать единственное, если возможно, решение, что также может потребовать дополнительных усилий со стороны разработчиков. Современные интегрированные среды разработки помогают в решении данной задачи, однако сам факт того, что для по крайней мере корректного использования концепции классов типов в Scala может потребоваться использование сторонних и, очевидно, достаточно сложных утилит, приводит к выводу о том, что представленный подход может быть упрощен.    

\section{Классы типов в \cpp}

В языке программирования \cpp отсутствует понятие класса типов, однако существует механизм \emph{частичной специализации шаблонов} (\emph{partial template specialization}), который предоставляет аналогичные возможности. Данный механизм предполагает наличие некоторого шаблонного класса, который принято называть \emph{первичным шаблоном} (\emph{primary template}), и позволяет определять новые типы на базе этого класса путем фиксирования значений любых типовых переменных из его шаблона. Стоит отметить, что, строго говоря, концепция частичной специализации шаблонов в \cpp является намного более мощной в смысле выразительности, нежели классы типов. Также возникают сложности с переносом семантики классов типов на языковые конструкции, описывающие частичные спецификации шаблонов. Так, например, объявление базового шаблонного класса можно условно считать аналогом объявления класса типов в Haskell, однако стоит понимать, что в шаблонном классе типов могут отсутствовать определения функций. То есть в контексте классов типов, шаблонный класс играет роль идентификатора, объединяющего некоторое множество типов, и в то же время не предполагает (по крайней мере в явном виде) наличие одинакового набора операций для каждого экземпляра. 

Рассмотрим объявление частично специализированных шаблонов на примере, представленном в листинге \ref{lst:partial-specializations-example}. Здесь определяется первичный шаблон \code{A} с двумя типовыми аргументами, после чего определяются две его частичные и одна полная специализации. 

\lstinputlisting[
    label={lst:partial-specializations-example},
    caption={Пример объявления частично специализированных шаблонов в \cpp},
    style={w_caption}
]
{resources/04/09_partial_specializations_example}

Все частичные специализации должны быть определены в том же пространстве имен, что и их первичный шаблон. Более того, частичные спецификации доступны тогда и только тогда, когда доступен их первичный шаблон. В частности, объявление, которое делает первичный шаблон видимым, делает доступными также и его частичные специализации. Так, например, в листинге \ref{lst:partial-specializations-namespace}, тип переменной \code{z} будет принят равным частичной специализации шаблона \code{Z} при \code{T} равном \code{int}.

\lstinputlisting[
    label={lst:partial-specializations-namespace},
    caption={Пример управления пространствами имен для частичных спецификаций в \cpp},
    style={w_caption}
]
{resources/04/10_partial_specializations_namespace}

Во время инстанцирования шаблонного класса и при наличии частичных спецификаций для него компилятор выбирает, какой именно шаблон должен быть использован, следующим образом:
\begin{itemize}
    \item Если существует единственная подходящая частичная специализация, то используется именно эта частичная специализация.
    \item Если существует более одной подходящей частичной специализации, среди них выбирается единственная, наиболее точная с точки зрения множества допустимых ею типов. Если наиболее точная частичная специализации не может быть определена, программа не может быть скомпилирована.    
    \item Если никакая частичная специализация не удовлетворяет значениям шаблонных аргументов, используется первичный шаблон.
\end{itemize}
Таким образом, для всякой пары первичного шаблона и набора значений, удовлетворяющих его шаблонным параметрам, во всей программе может существовать не более одной частичной специализации. Если отождествлять объявление экземпляра класса типов с определением частично специализированных шаблонов, то в контексте классов типов это означает, что уникальность экземпляра класса типов гарантируется не только в каждой точке вызова функции, использующей классы типов, но также и на уровне программы в целом. Также стоит отметить, что такой процесс вычисления подходящего экземпляра класса типов позволяет избежать введения ограничений на принадлежность типовой переменной классу типов, поскольку для всякого допустимого значения шаблонного параметра существует по крайней мере первичный шаблон, который заведомо ему удовлетворяет. 

Объявление членов частично специализированных шаблонов может быть определено как внутри объявления частичной специализации, так и отдельно от него, как показано в листинге \ref{lst:partial-specializations-members}. 

\lstinputlisting[
    label={lst:partial-specializations-members},
    caption={Пример объявления членов в частичных специализациях шаблонов в \cpp},
    style={w_caption}
]
{resources/04/11_partial_specializations_members}

 Таким образом, в контексте классов типов появляется возможность расширять функциональность каждого экземпляра класса типов по отдельности, независимо друг от друга и от определения соответствующего класса типов. Рассмотрим пример решения поставленной ранее задачи введения операции сравнения над некоторым конечным множеством типов при помощи частичных специализаций шаблонов, представленный в листинге \ref{lst:cpp-example}.
 
 \lstinputlisting[
    label={lst:cpp-example},
    caption={Пример использования частичных специализаций шаблонов в \cpp},
    style={w_caption}
]
{resources/04/12_cpp_example}

Возвращаясь к введенной ранее семантике классов типов для частичных специализаций шаблонов, можно сказать, что в листинге \ref{lst:cpp-example} был объявлен класс типов \code{CanEq}, а затем был определен его экземпляр для типа \code{bool}. 

\section{Выводы \label{sct:overview-conclusion}}

Выше были рассмотрены подходы к реализации механизмов классов типов в нескольких языках программирования. Во всех рассмотренных случаях использование классов типов предполагает наличие языковых конструкций, которые позволяют объявить класс типов и его экземпляры, а также ввести ограничение на принадлежность типовой переменной классу типов. Семантически класс типов представляет собой группу (множество) типов, для каждого из которых определены по крайней мере все операции из некоторого набора. При этом для всякого типа из этой группы все обязательные операции над ним определяются отдельно от самого типа. 

Несмотря на то, что классы типов были впервые представлены в функциональном языке программирования Haskell, эта концепция интуитивно понятным образом может быть перенесена на объектно-ориентированные языки программирования. Здесь стоит отметить, что в объектно-ориентированных языках программирования присутствует механизм перегрузок функций, который также обеспечивает функционирование специального полиморфизма. Классы типов, однако, представляют более мощную форму данного механизма. Ключевым фактором здесь является возможность определения реализаций функций, присущих классу типов, отдельно от типов, которые входят в этот класс. Для вызова специально полиморфной функции при использовании механизма перегрузок необходимо иметь экземпляр класса, в котором эта функция определена, или любого его наследника. Таким образом, в объектно-ориентированных языках программирования вызов специально полиморфных функций не может существовать отдельно от переменных. При использовании классов типов, однако, реализация специально полиморфной функции вычисляется на основании типов, используемых в рассматриваемой точке вызова, что позволяет, например, определять параметрически полиморфные функции, которые не принимают ни одного аргумента. Важно также отметить, что механизм перегрузок функций работает динамическим образом, то есть функция, которая будет использована, вычисляется уже на этапе исполнения программы, в то время как механизм классов типов выбирает подходящую реализацию статическим образом.

Во всех рассмотренных в данном разделе примерах использования классов типов учитывается наличие только одной типовой переменной, однако все представленные выше рассуждения и утверждения очевидным образом распространяются и на случай нескольких типовых переменных.