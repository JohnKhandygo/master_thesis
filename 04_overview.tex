%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор существующих решений}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе рассмотрим примеры реализации механизма классов типов в языках программирования Haskell и  Scala.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Классы типов в Haskell \label{sct:overview-haskell}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В языке программирования Haskell механизм классов типов состоит из трех частей: \emph{объявление класса типов} (\emph{type class declaration}), \emph{объявление экземпляра класса типов} (\emph{type class instance declaration}) и \emph{специализированных типов} (\emph{qualified types}). Рассмотрим все три составляющие на примере простейшей задачи реализации оператора сравнения над некоторым конечным множеством типов. В Haskell отсутствуют классы в том виде, как они представлены в объектно-ориентированном программировании, также отсутствует и механизм наследования. Для решение поставленной задачи необходимо использовать классы типов. 

Объявление класса типов определяет именованный набор операций, для каждой из которых определены типы всех аргументов, а также тип возвращаемого значения. Таким образом, объявление класса типов схоже с объявлением интерфейса в объектно-ориентированных языках программирования. Пример объявления класса типов для решения поставленной задачи приведен в листинге \ref{lst:haskell-example-define-typeclass}.    

\lstinputlisting[
    firstline=1,
    lastline=3,        
    label={lst:haskell-example-define-typeclass},
    caption={Пример определения класса типов в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Здесь \lstinline{CanEq} --- имя определяемого класса типов, \lstinline{a} --- типовая переменная. Данное определение следует трактовать следующим образом: <<всякий тип \lstinline{a}, принадлежащий к классу типов \lstinline{CanEq} имеет две операции \lstinline{eq} и \lstinline{neq}, каждая из которых возвращает значение типа \lstinline{Bool}, когда применяется к двум аргументам типа \lstinline{a}>>. Также можно определить реализацию по умолчанию для любой из объявленных в \lstinline{CanEq} функций. В данном случае это достаточно легко, поскольку каждый из представленных операторов может быть выражен через другой. Реализация данных функций таким образом, конечно, приведет к бесконечной рекурсии, поэтому достаточно определить хотя бы одну из них. Для этого к определению классового типа необходимо добавить строчку как показано в листинге \ref{lst:haskell-example-default-impl}.

\lstinputlisting[
    firstline=4,
    lastline=4,        
    label={lst:haskell-example-default-impl},
    caption={Пример предоставления реализации по умолчанию для классов типов в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Теперь предположим, что необходимо отнести стандартный тип Haskell \lstinline{Bool} к классу типов \lstinline{CanEq}. Для этого необходимо объявить экземпляр класса типов \lstinline{CanEq} для типа \lstinline{Bool} как показано в листинге \ref{lst:haskell-example-define-instance}.

\lstinputlisting[
    firstline=6,
    lastline=9,        
    label={lst:haskell-example-define-instance},
    caption={Пример объявления экземпляра класса типов в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Объявление экземпляра класса типов начинается с ключевого слова \lstinline{instance}, затем указывается имя классового типа, а вместо типовой переменной \lstinline{a} теперь указывается тип, для которого определяется экземпляр. В теле объявления экземпляра класса типов реализуются все функции, объявленные в классе типов. Здесь также важно отметить, что в Haskell допускается существование не более одного экземпляра для всякой пары класса типов и конкретного типа. 

Специализированные типы в свою очередь позволяют выразить ограничение на принадлежность типовой переменной некоторому классу типов. Так, например, можно объявить функцию \lstinline{memberOf} как показано в листинге \ref{lst:haskell-example-test}. 

\lstinputlisting[
    firstline=11,
    lastline=11,        
    label={lst:haskell-example-test},
    caption={Пример функции, использующей специализированные типы в Haskell},
    style={haskell}
]
{resources/04/01_haskell_example}

Такое определение следует трактовать следующим образом: <<для всякого типа \lstinline{t}, принадлежащего к классу типов \lstinline{CanEq}, функция \lstinline{memberOf} принимает два аргумента типов \lstinline{t} и списка над типом \lstinline{t} и возвращает значение типа \lstinline{Bool}>>. Префикс \lstinline{CanEq t =>} в типе функции \lstinline{memberOf} --- это часть синтаксиса Haskell, которая и делает тип специализированным.

На стадии компиляции информация, предоставляемая объявлениями классов типов и их экземпляров и специализированными типами, преобразуется следующим образом:
\begin{itemize}
    \item Для всякого объявления класса типов генерируется описание словаря функций этого класса типов. Словарь функций представляется в виде структуры данных, содержащей указатели на функции, описание которых (имя, сигнатура) в точности соответствует описанным в классе типов. 
    \item Для всякого объявления экземпляра класса типов генерируется словарь, в котором каждая запись теперь указывает на соответствующую реализацию. 
    \item Для каждой функции специализированного типа в список ее аргументов добавляется параметр-словарь, соответствующий классу типов, используемому в данной функции.
    \item Для каждого вызова функции специализированного типа компилятор ищет подходящий экземпляр соответствующего класса типов, и  в случае успеха передает его вместе со списком остальных аргументов в точку вызова. 
\end{itemize}
Ниже, в листинге \ref{lst:haskell-example-pseudo-impl} представлен код, демонстрирующий описанные выше преобразования на примере рассмотренной ранее задачи. 

\lstinputlisting[
    label={lst:haskell-example-pseudo-impl},
    caption={Пример псевдокода, который генерирует компилятор Haskell при работе с классами типов},
    style={haskell}
]
{resources/04/02_haskell_example_pseudo_impl}

Здесь стоит отметить, что, хотя код, представленный в листинге \ref{lst:haskell-example-pseudo-impl}, решает поставленную задачу без использования классов типов, такое решение достаточно сложно использовать, поскольку в точке вызова функции \lstinline{memberOf} пользователь ответственен за то, чтобы передать в функцию словарь правильного типа (в то время как в случае использования классов типов за это отвечает компилятор). Такой вариант может <<успешно>> использоваться в случае, когда все экземпляры класса типа наперед известны, однако использование его в сторонних приложениях, равно как и поддержка, могут привести к определенного рода сложностям и требуют дополнительных усилий от пользователей.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Классы типов в Scala}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В языке программирования Scala классы типов являются шаблоном проектирования, который основан на более общем механизме \emph{неявных деклараций} (\emph{implicits}). Данное расширение языка Scala позволяет при помощи ключевого слова \lstinline{implicit} описать неявное преобразование типов (implicit classes) или неявные аргументы функций (implicit arguments). Как и в Haskell, для использование классов типов в Scala состоит из трех частей: объявлений класса типов, его экземпляров и ограничений на типовые переменные, которые в Scala носят название \emph{контекстных ограничений} (\emph{context bounds}). Scala, однако, является объектно-ориентированным языком программирования и потому каждый из этих этапов реализован несколько иначе, чем в Haskell. Отличие выражается в следующих аспектах:
\begin{itemize}
    \item Объявление класса типов в Scala аналогично описанию параметризованного интерфейса. 
    \item Объявление экземпляров класса типов реализовано через механизм наследования: необходимо реализовать интерфейс, соответствующий классу типов, для требуемых конкретных типов. 
    \item Принадлежность типовой переменной классу типов выражается через оператор наследования, либо путем декларации неявного аргумента, который в теле функции может быть использован как словарь.
    \item Поиск подходящего словаря осуществляется не только на основании параметров вызова, но также и с использованием области видимости в точке вызова. Выбор конкретного экземпляра класса типов происходит путем ранжирования всех доступных областей видимости. В случае, если по данному критерию выявлено более одного кандидата, выбор будет сделан в пользу наиболее точного в соответствии с правилами статического разрешения перегрузок.   
\end{itemize}
В первых трех аспектах просматривается определенная аналогия с языком программирования Haskell, последний же вносит существенное отличие, поскольку именно благодаря такой стратегии поиска подходящего экземпляра допускается существования более одной реализации для всякой пары класса типов и конкретного типа. С одной стороны, такой подход представляется более гибким с точки зрения управления зависимостями, с другой стороны, он привносит определенную долю неоднозначности, поскольку не понятно, какая из реализаций в действительности будет использована.   

\lstinputlisting[
    label={lst:scala-example},
    caption={Пример использования классов типов в Scala},
    style={scala}
]
{resources/04/03_scala_example}

\section{Выводы \label{sct:overview-conclusion}}

Выше были рассмотрены подходы к реализации классов типов в двух языках программирования. Механизм, представленный в Scala, дает представление о том, какие элементы могут быть использованы для того, чтобы корректно и полно выразить все аспекты описания и использования классов типов в объектно-ориентированных языках программирования, однако возможность определения более одного экземпляра класса типов для одного и того же конкретного типа, делает его недостаточно прозрачным. Ограничение на единственную реализацию (как это сделано в Haskell) выглядит более естественным и понятным.