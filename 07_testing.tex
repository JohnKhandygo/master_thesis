\chapter{Анализ разработанного решения}

В данном разделе будут проанализированы преимущества и недостатки интегрированного решения. Также будет описана стратегия проверки корректности работы разработанного механизма классов типов, включающая в себя, как автоматическое, так и ручное тестирование.  

\section{Анализ разработанного решения}

Реализованный механизм, кажется, предоставляет пользователю всю необходимую для работы с классами типов функциональность: объявление классов типов и их экземпляров, ограничение принадлежности типовой переменной классу типов, а также вызов функций классов типов в контексте неизвестных на этапе исполнения значений типовых переменных. Полученное решения, конечно, нельзя назвать оптимальным даже в отношении синтаксиса использования классов типов, тем не менее оно дает достаточно полное представление о том, как подобный механизм может быть реализован. 

Ключевым элементом разработанного решения является модифицированный алгоритм разрешения вызовов функций, который может использовать значения типовых переменных для вычисления некоторых аргументов. Легко видеть, что почти вся функциональность, предоставляемая механизмом классов типов, обеспечивается именно этим алгоритмом. 

Среди недостатков разработанного подхода можно перечислить следующие:
\begin{itemize}
    \item Не допускается наследование между классами типов. Данное решение было принято еще на этапе разработки требований и объяснялось тем, что в противном случае нельзя гарантировать уникальность экземпляров классов типов. Несмотря на то, что формально такое решение все еще считается необходимым, оно не допускает некоторые сценарии использования классов типов, которые могли бы быть корректно разрешены с соблюдением требования уникальности экземпляров классов типов.  
    \item Областью поиска экземпляров классов типов является вся программа. На первый взгляд, это также не является большой проблемой, однако при ближайшем рассмотрении можно заметить, что зависимость вызова функции от некоторого экземпляра класса типов не выражена нигде в явном виде. Другими словами, пользователь в общем случае не может знать достоверное местоположение объявление интересующего его экземпляра класса типов.  
    \item Способ включения экземпляров классов типов, определения которых встречаются в сторонних библиотеках, в список доступных экземпляров внутри программы также может затруднять понимание кода, поскольку разработанный механизм никаким образом не ограничивает места программы, в которых эти включения могут быть описаны. 
    \item Неявные аргументы, играющие роль словарей функций классов типов, которые генерируются компилятором для функций, использующих классы типов, доступны для использования в теле таких функций в явном виде. С одной стороны, в этом нет никакой проблемы, однако исходный код, использующий эти неявные переменные напрямую может быть сложен для понимания. К тому же, разработанный механизм предоставляет пользователю доступ к этим переменным через вызов функции \code{dictionaryOf}. 
\end{itemize}
Некоторые из перечисленных выше недостатков можно устранить введением правил кодирования, которые строго регламентируют места описания и включения экземпляров классов типов. Также стоит рассмотреть следующие функциональные особенности для реализации в будущем:
\begin{itemize}
    \item Расширение доступных способов инстанцирования экземпляров классов типов. В рамках данного расширения могут быть рассмотрены не только функции, инстанцирующие экземпляры классов типов динамическим образом, но также и особый случай автоматического преобразования переменных к экземплярам классов типов, конструктор которых имеет единственный аргумент.  
    \item Интегрировать механизм, позволяющий описывать ограничения на принадлежность типовых переменных классам типов не только в функциях, но также и при определении классов.
\end{itemize}

\section{Тестирование}

Все модификации, рассмотренные выше, за исключением генерации байт-кода функций-делегатов, предоставляющих доступ к функциям классов типов, затрагивают только ту часть компилятора, которая отвечает за анализ исходного кода программы. При этом большинство разработанных алгоритмов обеспечивает корректное разрешение вызовов функций, использующих классы типов. Таким образом, тестирование только лишь процесса разрешения вызовов с использованием класса типов представляется достаточным для того, чтобы удостовериться в корректности работы всего механизма классов типов. Также стоит отметить, что исходный код компилятора Kotlin поставляется вместе с набором тестов, который насчитывает более двадцати тысяч модульных тестов компилятора. Корректное исполнение этих тестов, в свою очередь, позволяет обосновать тот факт, что описанные выше изменения не влияют негативным образом на базовую функциональность компилятора. 

Для реализации модульных тестов, проверяющих работу механизма разрешения вызовов, в компиляторе существует специальный класс \code{AbstractResolvedCallsTest}. Для всякого тестового метода, объявленного в наследниках этого класса, необходимо создать два файла, один из которых содержит компилируемый код и допускает использование специального выражения \code{<caret>} перед вызовом, содержимое второго состоит из двух частей: копии содержимого первого файла и информации о разрешенных вызовах, помеченных \code{<caret>}. Пример файла второго типа для одного из разработанных модульных тестов представлен ниже в листинге \ref{lst:test-file-example}.

\lstinputlisting[
    label={lst:test-file-example},
    caption={Пример файла, описывающего результат разрешения вызовов в тестах},
    style={kotlin}
]
{resources/06/16_test_file_example}  